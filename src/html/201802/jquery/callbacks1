
jquery: 2.0.3
--------------------------------------------------------------------------------
Deferred
一个工厂函数，这个函数返回一个链式实用对象，用返回对象方法来在回调队列中注册多个回调， 调用回调队列，
传递任何同步或异步函数的成功或失败状态。
返回的deferred对象是包含state，always，catch，pipe，then，promise，progress、done、fail、notify、notifyWith
resolve、resolveWith、reject、rejectWith方法。


基本结构
jQuery.Deferred=function(func){
     var tuples= [

                                // action, add listener 监听, callbacks 回调列表, then处理函数handles ， 参数索引，终止状态
                                // ... .then handlers, argument index, [final state]
                                [ "notify", "progress", jQuery.Callbacks( "memory" ),
                                    jQuery.Callbacks( "memory" ), 2 ],
                                [ "resolve", "done", jQuery.Callbacks( "once memory" ),
                                    jQuery.Callbacks( "once memory" ), 0, "resolved" ],
                                [ "reject", "fail", jQuery.Callbacks( "once memory" ),
                                    jQuery.Callbacks( "once memory" ), 1, "rejected" ]
                            ];
     var state="pending";
     var promise={
        state:function
        always:function
        catch:function
        pipe:function
        then:function
        promise:function
     };//后面each中还加了progress、done、fail三个函数，分别给这三个状态的callbacks新增回调函数用的

     var deferred={};

      jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],//rejected_callbacks,fulfilled_callbacks,progress_callbacks
            stateString = tuple[ 5 ];//状态，resolved、rejected
            promise[ tuple[ 1 ] ] = list.add; //此处给progress、done、fail加$.callbacks返回add函数，此后add执行后返回的是this时promise
            //callbacks列表加5个函数分别是
             if ( stateString ) {//完成状态和拒绝状态给rejected_callbacks,fulfilled_callbacks加回调函数到队列中
                    list.add(
                        function() {  state = stateString;},
                        tuples[ 3 - i ][ 2 ].disable,   // rejected_callbacks.disable、 fulfilled_callbacks.disable
                        tuples[ 3 - i ][ 3 ].disable,   //rejected_handlers.disable、fulfilled_handlers.disable
                        tuples[ 0 ][ 2 ].lock,  //progress_callbacks.lock
                        tuples[ 0 ][ 3 ].lock   //progress_handlers.lock
                    );
                }
             //deferred对象根据tuples元祖绑定六个函数，如 deferred.notify = function() { deferred.notifyWith(...) } deferred.resolve = function() { deferred.resolveWith(...) }
            deferred[ tuple[ 0 ] ] = function() {
                deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
                return this;
            };

            // deferred.notifyWith = list.fireWith  ，deferred.resolveWith = list.fireWith ，deferred.rejectWith = list.fireWith
            deferred[ tuple[ 0 ] + "With" ] = list.fireWith;

      })

      promise.promise( deferred );

      if ( func ) {
                 func.call( deferred, deferred );
      }
    return deferred;
}

jQuery.when=function(){
      ...........
     return master.promise();
}

//
-----
promise.promise(obj)
    将promise对象上的方法合并到obj传参上，如果obj为null则直接返回promise变量

 promise: function( obj ) {   return obj != null ? jQuery.extend( obj, promise ) : promise;      }


-----
promise.pipe()
源码：
    pipe: function( /* fnDone, fnFail, fnProgress */ ) {
        var fns = arguments;//三个函数参数

        return jQuery.Deferred( function( newDefer ) { //此处传的方法会在jQuery.Deferred中初始化完deferred对象后立即执行
            jQuery.each( tuples, function( i, tuple ) {

                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                //根据元组中的索引，将元组中的(progress, done, fail)与参数(done, fail, progress)对应起来，
                //取某一函数做相应的绑定处理
                var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

                //deferred上绑定三种函数，deferred变量初始化时绑定的progress、done、fail加$.callbacks返回add函数，
                //如rejected_callbacks的add函数就是deferred.fail，这里执行deferred[ tuple[ 1 ] ]()-
                // deferred.fail(funx)就是在rejected_callbacks列表加一个函数，待fire时处理。
                //  添加的函数内容是 处理用户的参数函数，如果用户的函数返回值是promise，
                // 则给promise对应的三种状态函数传新的deferred的触发函数reject、resolve、notify
                //因为：deferred.reject = function() { deferred.rejectWith(...) } -> deferred.rejectWith = list.fireWith -> fire();
                //progress /done/fail调用后返回的都是promise对象所以可以连写

                // deferred.progress(function() { bind to newDefer or newDefer.notify })
                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                // deferred.fail(function() { bind to newDefer or newDefer.reject })
                deferred[ tuple[ 1 ] ]( function() {
                    var returned = fn && fn.apply( this, arguments );
                    if ( returned && isFunction( returned.promise ) ) {
                        returned.promise()
                            .progress( newDefer.notify )
                            .done( newDefer.resolve )
                            .fail( newDefer.reject );//如果pipe返回的newDefer有被处理则这里的newDefer.reject 等的处理会在后续触发
                    } else {
                        newDefer[ tuple[ 0 ] + "With" ](
                            this,
                            fn ? [ returned ] : arguments
                        );
                    }
                } );
            } );
            fns = null;
        } ).promise();
    },



------promise.then()

        then: function( onFulfilled, onRejected, onProgress ) {
                    var maxDepth = 0;
                    function resolve( depth, deferred, handler, special ) {
                        return function() {
                            var that = this,
                                args = arguments,
                                mightThrow = function() {
                                    var returned, then;

                                    // Support: Promises/A+ section 2.3.3.3.3
                                    // https://promisesaplus.com/#point-59
                                    // Ignore double-resolution attempts
                                    if ( depth < maxDepth ) {
                                        return;
                                    }

                                    returned = handler.apply( that, args );

                                    // Support: Promises/A+ section 2.3.1
                                    // https://promisesaplus.com/#point-48
                                    if ( returned === deferred.promise() ) {//如果handler处理结果返回值是promise，则抛出类型异常
                                        throw new TypeError( "Thenable self-resolution" );
                                    }

                                    // Support: Promises/A+ sections 2.3.3.1, 3.5
                                    // https://promisesaplus.com/#point-54
                                    // https://promisesaplus.com/#point-75
                                    // Retrieve `then` only once
                                    then = returned &&

                                        // Support: Promises/A+ section 2.3.4
                                        // https://promisesaplus.com/#point-64
                                        // Only check objects and functions for thenability
                                        ( typeof returned === "object" ||
                                            typeof returned === "function" ) &&
                                        returned.then;

                                    // Handle a returned thenable
                                    if ( isFunction( then ) ) {

                                        // Special processors (notify) just wait for resolution
                                        //特殊处理器（通知）只是等待resolution
                                        if ( special ) {
                                            then.call(
                                                returned,
                                                resolve( maxDepth, deferred, Identity, special ),
                                                resolve( maxDepth, deferred, Thrower, special )
                                            );

                                            // Normal processors (resolve) also hook into progress
                                        } else {

                                            // ...and disregard older resolution values
                                            maxDepth++;

                                            then.call(
                                                returned,
                                                resolve( maxDepth, deferred, Identity, special ),
                                                resolve( maxDepth, deferred, Thrower, special ),
                                                resolve( maxDepth, deferred, Identity,
                                                    deferred.notifyWith )
                                            );
                                        }

                                        // Handle all other returned values
                                    } else {

                                        // Only substitute handlers pass on context
                                        // and multiple values (non-spec behavior)
                                        //只替代处理程序handlers传递上下文和多个值（非规范行为）
                                        if ( handler !== Identity ) {
                                            that = undefined;
                                            args = [ returned ];
                                        }

                                        // Process the value(s) 处理值
                                        // Default process is resolve
                                        ( special || deferred.resolveWith )( that, args );
                                    }
                                },

                                // Only normal processors (resolve) catch and reject exceptions
                                //只有正常的处理器processors（resolve）捕获并拒绝异常
                                process = special ?
                                    mightThrow :
                                    function() {
                                        try {
                                            mightThrow();
                                        } catch ( e ) {

                                            if ( jQuery.Deferred.exceptionHook ) {
                                                jQuery.Deferred.exceptionHook( e,
                                                    process.stackTrace );
                                            }

                                            // Support: Promises/A+ section 2.3.3.3.4.1
                                            // https://promisesaplus.com/#point-61
                                            // Ignore post-resolution exceptions
                                            //忽略 post-resolution  后的异常
                                            if ( depth + 1 >= maxDepth ) {

                                                // Only substitute handlers pass on context
                                                // and multiple values (non-spec behavior)
                                                //只有替代处理程序传递上下文和多个值（非规范行为）
                                                if ( handler !== Thrower ) {
                                                    that = undefined;
                                                    args = [ e ];
                                                }

                                                deferred.rejectWith( that, args );
                                            }
                                        }
                                    };

                            // Support: Promises/A+ section 2.3.3.3.1
                            // https://promisesaplus.com/#point-57
                            // Re-resolve promises immediately to dodge false rejection from
                            // subsequent errors
                            //立即重新Re-resolve promises，以避免后续错误的错误rejection
                            if ( depth ) {
                                process();
                            } else {

                                // Call an optional hook to record the stack, in case of exception
                                // since it's otherwise lost when execution goes async
                                //回调一个可选的钩子记录堆栈，以防异常当执行异步时它会丢失
                                if ( jQuery.Deferred.getStackHook ) {
                                    process.stackTrace = jQuery.Deferred.getStackHook();
                                }
                                window.setTimeout( process );
                            }
                        };
                    }

                    return jQuery.Deferred( function( newDefer ) {

                        // progress_handlers.add( ... )
                        tuples[ 0 ][ 3 ].add(
                            resolve(
                                0,
                                newDefer,
                                isFunction( onProgress ) ?
                                    onProgress :
                                    Identity,
                                newDefer.notifyWith
                            )
                        );

                        // fulfilled_handlers.add( ... )
                        tuples[ 1 ][ 3 ].add(
                            resolve(
                                0,
                                newDefer,
                                isFunction( onFulfilled ) ?
                                    onFulfilled :
                                    Identity
                            )
                        );

                        // rejected_handlers.add( ... )
                        tuples[ 2 ][ 3 ].add(
                            resolve(
                                0,
                                newDefer,
                                isFunction( onRejected ) ?
                                    onRejected :
                                    Thrower
                            )
                        );
                    } ).promise();
                },



-------------------------------------------------------------------------------------------------------
CallBacks
'once':
    回调函数列表只回调一次，如果没有附加“memory”模式，则一次回调后list,memory,stack都为undefined，之后什么都不能做
    list：存放回调函数列表。
    初始化化时stack触发函数fire的传参列表赋值为false，表示这个列表只被触发一次，没有必要再缓存fire传的参数

    firing标志是否正在处理回调函数列表，
'memory'
    如果已经fire过一次处理了list，则add注册新的回调函数时，会回调回调列表中本次添加的函数，参数是上一次缓存的参数。
    如果是第一次fire（此时fire之前add时memory都为undefined不会自动fire()），则直接回调列表中所有已经添加的函数。
'unique'
    同一个注册函数只能在列表中加一次
'stopOnFalse'
    执行回调函数列表中的函数时如果遇到返回值为false 后面的函数不再执行，memory=false。
     如果还附加了memory模式，阻止此后再用add注册回调函数时触发fire，就是新增的函数不再自动回调。
    如果列表处理结束stack不为空时，继续调用fire，此时如果列表中所有函数都没有返回false，之前的memory=false是不是失效了？



fireWith：
    回调函数列表存在，且未被触发过或者stack不为false或undefined ，如果firing=true 回调列表中的函数正在被处理（回调）
    ，则将本次触发参数先存入stack。等list中从firingIndex到firingLength-1正在被“锁定”处理回调的处理完成，
    下面还会从stack取出再一次fire触发处理，此时一般从列表开头0开始里面的函数都回调一遍，如果是memory模式且add新函数，
    则把这个新增的处理函数的下标作为从函数列表中开始回调的初始位置，add后直接fire一次fire( memory ) 传的是上一次的参数。

add :
    如果传入的参数是函数（如果是数组或类数组则递归到取得函数值子项），如果unique 为true（unique：同一个处理函数最多在list列表中加一次）
    且已经在列表中加过了就不再加，其他情况可以重复添加同一个处理函数。
    如果firing=true回调列表正在进行回调处理，可以赋值firingLength = list.length，
    让处理新加的函数也在未循环完接着处理，此处是不是一般不太可能出现，待查 webworker多个共享处理？
    如果memory有值，则直接触发本次添加的回调函数，参数就是上一次缓存的值memory。
fire ：
    传参第一个是处理list中回调函数的上下文，第二参数是self.fire传入的给回调函数调用的参数。
    memory 如果这个list是“momery”模式，则将data缓存为memory最近的用于回调的参数供add时调用。
    标记 fired = true; 回调列表被回调过，
    firingIndex赋值接下来要处理的list中函数项的开始位置（如果是memory模式，且add的时候fire回调从本次新加的函数开始，
    其他情况从0开始）。
    循环回调函数列表list来回调用户注册函数。处理过程中如果遇到某个函数的返回结果是false且用户使用了“stopOnFalse”模式，
    则列表中后面的函数不再调用，同时memory =false ，即使假如还要“momery”模式，阻止此后再用add注册回调函数时触发fire。
    stack :memory、unique、stopOnFalse模式会进入此分支，stack不是undefined或false（为once时）都会先进这里，
    disable或lock后 list = stack = memory = undefined;之后触发就失效了

lock：
    锁住当前list状态，stack=undefined 以后fire调用列表中的函数后不再存待触发的参数列表，
    如果memory 为false（stopOnFalse且函数返回false时）直接调用disabled（）。即如果stopOnFalse且函数返回false时，
    列表全部清空，调用fire不会再回调列表，add也不能再注册回调函数了。固化了这个列表处理过的状态，以后什么操作都不能做了。


关键点：
    1.memory 模式，之前add 和fire过再次add，会主动调用fire 函数处理本次新增函数，即传入上一次缓存的memory参数并回调新增的函数。
    2.unique模式：   同一个注册函数只能在列表中加一次
    3.once模式： 回调函数列表只回调一次，如果没有附加“memory”模式，则一次回调后list,memory,stack都为undefined，之后什么都不能做
    4.stopOnFalse模式：执行回调函数列表中的函数时如果遇到返回值为false 后面的函数不再执行，memory=false。
        如果还附加了memory模式，阻止此后再用add注册回调函数时触发fire,就是新增的函数不再自动回调。
     如果列表处理结束stack不为空时，继续调用fire，此时如果列表中所有函数都没有返回false，之前的memory=false是不是失效了？


问题：
为什么要使用firing,fire中的处理不是同步进行的吗？