<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<script type="text/javascript">
/*https://zhuanlan.zhihu.com/p/25178630*/
var PENDING = 0;
var FULFILLED =1 ;
var REJECTED = 2;
function Promise(fn){ //fn一般是包含异步处理的函数
	if( typeof this !=='object'){// new 后this指向新变量对象
		throw new TypeError("promises must bu constructed via new");
	}
	if(typeof fn !=='function'){
		throw new TypeError("fn must be a function");
	}
	var state = PENDING;
	var value = null;
	var handlers =[];
	
	function doResolve(fn,onFulfilled,onRejected){
		var done = false; 
		try{
            //此处的fn 是用户传入的带简单参数的函数(如例子中的带参数success,fail的函数)
            // 或 then中return的promise对象的then函数（由getThen处理）
            //
			fn(function(value){
				//用户调用成功函数，传参value
				if(done) return ;
				done = true;
				onFulfilled(value);//用于后续处理传到后面then的对应函数参数中
			},function(reason){
				if(done) return;
				done = true;
				onRejected(reason); 
			})
		}catch(e){
			if(done) return;
			done = true;
			onRejected(e);
		}
	}

	function getThen(value){//辅助判断是否是promise对象
		var t = typeof value;
		if(value &&(t==='object'||t === 'function')){
			var then = value.then;
			if(typeof then === 'function'){
				return then;
			}
		}
		return null;
	}
	function resolve(result){
		//resolve 用户函数fn处理后调用resolve，由doResolve转接到这里
		//result 用户回调函数处理后返回的结果
		try{
			var then = getThen(result);
			if(then){//传promise对象时
                //将then函数绑定到用户调用解决时传的promise对象上
				doResolve(then.bind(result),resolve,reject);
				return;
			}
			state = FULFILLED;
			value = result;
			handlers.forEach(handle);
			handlers = null;
		}catch(e){
			
		}
	}
	function reject(error){
		state = REJECTED;
		value = error;
		handlers.forEach(handle);
		handlers=null
	}
	function handle(handler){
		if(state === PENDING){
			handlers.push(handler);
		}else{
			if(state === FULFILLED && typeof handler.onFulfilled ==='function'){
				handler.onFulfilled(value);
			}
			if(state === REJECTED && typeof handler.onRejected === 'function'){
				handler.onRejected(value);
			}
		}
	}

	this.done = function(onFulfilled,onRejected){
		setTimeout(function(){//表示异步调用处理函数

			handle({
				onFulfilled:onFulfilled,
				onRejected:onRejected
			});
		},0)
	}
	
	this.then = function(onFulfilled,onRejected){
		var self = this;//promise对象同时也返回一个新promise对象

		return new Promise(function(resolve,reject){
			
			var done1= self.done(function(result){
				if(typeof onFulfilled === 'function' ){
					try{
						return resolve(onFulfilled(result));//
					}catch(e){
						return reject(e);			
					}
				}else{//用户then中未传参数
					return resolve(result);			
				}
			},function(error){
				if(typeof onRejected ==='function'){
					try{
						return resolve(onRejected(error));
					}catch(e){
						return reject(e);
					}
				}else{
					return reject(error);
				}
			});
			return done1;
			
		});
	}

    //fn用于转接处理，resolve在fn处理成功时调用，处理出错时调用reject。
    //而处理结束时决定回调resolve还是reject由用户fn 传的两个参数决定，
    //如果用户调用fn中的第一个参数则promise内部会调用resolve方法，
    //保证只进行一次状态改变(done=true)然后返回处理结果，供后续then获取
	doResolve(fn,resolve,reject);
	
}



/*
 var p = new Promise(function(success,fail){

	setTimeout(function(){
		console.log('第一个异步')
	//	resolve("hahha ");
        success("第一处");
	},2000)
}); 
p.then(function (value) {
    console.log("第一处返回值",value)
    return new Promise(function(success,fail){
        setTimeout(function(){
            console.log('第二个异步')
            //	resolve("hahha ");
            success("第二处");
        },1000)
    })
},function () {
    
}).then(function(result){
	console.log("succes2")
	console.log("第二处返回值",result)
},function(error){
	console.log("fail2")
	console.log(error);
})*/

    var p1 = new Promise(function(resolve,reject){
        setTimeout(function(){
            resolve("11")
        },100)
    })
    p1.then(function(){
            var p2=new Promise(function(res,rej){
                setTimeout(function(){res()},200)
            });
            return p2;
        },function(){

        }).then(function(){},function(){

        })

    // 每new一个promise都会执行doResolve。
    //p1.then(onFulfilled,onRejected),onFulfilled完成函数中返回的是一个promise，则
</script>

</body>
</html>